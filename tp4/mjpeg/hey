#!/usr/bin/env python
from dsx import *
from vgmn_noirq_multi import VgmnNoirqMulti
import sys

# Declaration of all MWMR fifos
tg_split        = Mwmr('tg_split'   , 32, 2)

split_demux1    = Mwmr('split_demux1'   , 32, 2)
split_demux2    = Mwmr('split_demux2'   , 32, 2)

demux_vld1  	= Mwmr('demux_vld1'  , 32, 2)
vld_iqzz1   	= Mwmr('vld_iqzz1'   , 128, 2)
iqzz_idct1  	= Mwmr('iqzz_idct1'  , 256, 2)
idct_libu1  	= Mwmr('idct_libu1'  , 64, 2)

demux_vld2  	= Mwmr('demux_vld2'  , 32, 2)
vld_iqzz2   	= Mwmr('vld_iqzz2'   , 128, 2)
iqzz_idct2  	= Mwmr('iqzz_idct2'  , 256, 2)
idct_libu2  	= Mwmr('idct_libu2'  , 64, 2)

huffman1    	= Mwmr('huffman1'    , 32, 2)
huffman2    	= Mwmr('huffman2'    , 32, 2)
quanti1     	= Mwmr('quanti1'     , 64, 2)
quanti2     	= Mwmr('quanti2'     , 64, 2)

libu_ramdac	= Mwmr('libu_ramdac', 48*8, 2)

tcg = Tcg(

    Task( 'tg', "tg",
          {'output':tg_split },
          defines = {'FILE_NAME':'"plan.mjpg"'}),
    
    Task( 'split', "split",
          { 'input':tg_split,
            'output1':split_demux1,
            'output2':split_demux2},
            defines = {'WIDTH':"48",
                       'HEIGHT':"48"}),
#Pipe one.
    Task( 'demux1', "demux",
          { 'input':split_demux1,
            'output':demux_vld1,
            'huffman':huffman1,
            'quanti':quanti1 },
            defines = {'WIDTH':"48",
                       'HEIGHT':"48"}),

    Task( 'vld1', "vld",
	  {'input':demux_vld1,
	   'output':vld_iqzz1,
	   'huffman':huffman1 },
            defines = {'WIDTH':"48",
                       'HEIGHT':"48"}),
    
    Task( 'iqzz1', "iqzz",
	  {'input':vld_iqzz1,
	   'output':iqzz_idct1,
	   'quanti':quanti1 },
            defines = {'WIDTH':"48",
                       'HEIGHT':"48"}),

    Task( 'idct1', "idct",
	  {'input':iqzz_idct1,
	   'output':idct_libu1},
            defines = {'WIDTH':"48",
                       'HEIGHT':"48"}),

#Pipe two.
    Task( 'demux2', "demux",
          { 'input':split_demux2,
            'output':demux_vld2,
            'huffman':huffman2,
            'quanti':quanti2 },
            defines = {'WIDTH':"48",
                       'HEIGHT':"48"}),

    Task( 'vld2', "vld",
	  {'input':demux_vld2,
	   'output':vld_iqzz2,
	   'huffman':huffman2 },
            defines = {'WIDTH':"48",
                       'HEIGHT':"48"}),
    
    
    Task( 'iqzz2', "iqzz",
	  {'input':vld_iqzz2,
	   'output':iqzz_idct2,
	   'quanti':quanti1 },
            defines = {'WIDTH':"48",
                       'HEIGHT':"48"}),

    Task( 'idct2', "idct",
	  {'input':iqzz_idct2,
	   'output':idct_libu2},
            defines = {'WIDTH':"48",
                       'HEIGHT':"48"}),

    Task( 'libu', "libu",
	  {'input1':idct_libu1,
	   'input2':idct_libu2,
	   'output':libu_ramdac},
            defines = {'WIDTH':"48",
                       'HEIGHT':"48"}),

    Task( 'ramdac', "ramdac",
          { 'input': libu_ramdac },
            defines = {'WIDTH':"48",
                       'HEIGHT':"48"}),
    )

p = Posix()
tcg.generate(p)
#########################################################
# Section B : Hardware architecture
#
# The file containing the architecture definition
# must be included, and the path to the directory
# containing this file must be defined
#########################################################

#proc_nb = 2
#dcache_l = int(sys.argv[1])
#icache_l = int(sys.argv[2])
#archi = VgmnNoirqMulti( proc_count = proc_nb, ram_count = 2, dcache_lines = dcache_l, icache_lines = icache_l)
#
##########################################################
## Section C : Mapping					#
##########################################################
#
#mapper = Mapper(archi, tcg)
#
## mapping the MWMR channel
#
#mapper.map( "tg_split",
#  buffer = "cram1",
#  status = "cram1"
#)
#mapper.map("split_demux1",
#  buffer = "cram1",
#  status = "cram1"
#)
#mapper.map("split_demux2",
#  buffer = "cram1",
#  status = "cram1"
#)
##1
#mapper.map( "demux_vld1",
#  buffer = "cram1",
#  status = "cram1"
#)
#mapper.map( "vld_iqzz1",
#  buffer = "cram1",
#  status = "cram1"
#)
#mapper.map( "iqzz_idct1",
#  buffer = "cram1",
#  status = "cram1"
#)
#mapper.map( "idct_libu1",
#  buffer = "cram1",
#  status = "cram1"
#)
##2
#mapper.map( "demux_vld2",
#  buffer = "cram1",
#  status = "cram1"
#)
#mapper.map( "vld_iqzz2",
#  buffer = "cram1",
#  status = "cram1"
#)
#mapper.map( "iqzz_idct2",
#  buffer = "cram1",
#  status = "cram1"
#)
#mapper.map( "idct_libu2",
#  buffer = "cram1",
#  status = "cram1"
#)
#
#mapper.map( "libu_ramdac",
#  buffer = "cram1",
#  status = "cram1"
#)
#mapper.map( "huffman1",
#  buffer = "cram1",
#  status = "cram1"
#)
#mapper.map( "quanti1",
#  buffer = "cram1",
#  status = "cram1"
#)
#mapper.map( "huffman2",
#  buffer = "cram1",
#  status = "cram1"
#)
#mapper.map( "quanti2",
#  buffer = "cram1",
#  status = "cram1"
#)
#
## mapping the "prod0" and "cons0" tasks
#mapper.map("split",
#   run   = "cpu1",
#   stack = "cram0",
#   desc  = "cram0"
#)
##1
#mapper.map("demux1",
#   run   = "cpu1",
#   stack = "cram0",
#   desc  = "cram0"
#)
#mapper.map("vld1",
#   run   = "cpu1",
#   stack = "cram0",
#   desc  = "cram0"
#)
#mapper.map("iqzz1",
#   run   = "cpu0",
#   stack = "cram0",
#   desc  = "cram0"
#)
#mapper.map("idct1",
#   run   = "cpu0",
#   stack = "cram0",
#   desc  = "cram0"
#)
##2
#mapper.map("demux2",
#   run   = "cpu1",
#   stack = "cram0",
#   desc  = "cram0"
#)
#mapper.map("vld2",
#   run   = "cpu1",
#   stack = "cram0",
#   desc  = "cram0"
#)
#mapper.map("iqzz2",
#   run   = "cpu0",
#   stack = "cram0",
#   desc  = "cram0"
#)
#mapper.map("idct2",
#   run   = "cpu0",
#   stack = "cram0",
#   desc  = "cram0"
#)
#
#mapper.map("libu",
#   run   = "cpu1",
#   stack = "cram0",
#   desc  = "cram0"
#)
## mapping the software objects associated to a processor
#for i in range(proc_nb):
#	  mapper.map( 'cpu%d'%i,
#	   		 private = "cram0",
#	   		 shared  = "uram0")
#
#mapper.map('tg',
#	  coprocessor = 'tg0',
#	  controller = 'tg0_ctrl'
#	  )
#mapper.map('ramdac',
#	  coprocessor = 'ramdac0',
#	  controller = 'ramdac0_ctrl'
#	  )
## mapping the software objects used by the embedded OS
#
#mapper.map(tcg,
#  private = "cram1",
#  shared  = "uram1",
#  code    = "cram1",
#
#  # These lines are for getting output messages:
#  tty = "tty0",
#  tty_no = 0)

######################################################
# Section D : Code generation                        #
######################################################

# Embedded software linked with the Mutek/S OS

#mapper.generate( MutekS() )
#mapper.generate( MutekH() )

# The software application for a POSX workstation can still be generated

#tcg.generate( Posix() )
